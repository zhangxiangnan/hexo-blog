java线程协作即2个线程如何交互，发信号，告诉对方一些信息，触发对方做一些事情。

### 一道题说起：
```
        public static void main(String[] args) {
            System.out.println("step1");
            Object obj = new Object();
            magic(obj);
            System.out.println("step2");
            synchronized (obj){
                System.out.println("step3");
            }
        }

```

问如何实现magic方法，使输出按如下顺序，且线程停留在为synchronized (obj)这行（注意：不输出step3）：

```
    step1
    step2
```

很明显，magic方法里需要获取obj的锁，因为需要返回到main函数，没法在magic方法里用主线程一直锁定obj，所以需要单独开一个线程来锁定obj。那么，子线程锁定obj，锁定多长时间呢，两个线程运行具有不确定性，既然不确定，就让子线程一直锁。如下：

```
     private static void magic(Object obj)  {
            Thread thread = new Thread(() -> {
                synchronized (obj){
                    while (true){
                    }
                }
            });
            thread.setName("xx");
            thread.start();
        }
```

magic启动子线程后，方法返回，main函数继续执行，此时可能子线程还没有锁定obj，导致和预期不一致。即我们要做的是子线程必须获取到obj锁，才能让magic返回，怎么让子线程告诉主线程我已经获取到了obj锁，你可以继续执行呢？

### 主线程睡眠一定时间？？
这种不靠谱，极端情况下子线程可能在设置的休眠时间内仍然没有得到运行；另外子线程极端时间内得到了锁，但是主线程确休眠，造成cpu浪费

```
    private static void magic(Object obj)  {
            Thread thread = new Thread(() -> {
                synchronized (obj){
                    while (true){
                    }
                }
            });
            thread.setName("xx");
            thread.start();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
```

#### 共享变量
```
    private static void magic(Object obj)  {
        final boolean[] getLock = {false};
        Thread thread = new Thread(() -> {
            synchronized (obj){
                getLock[0] = true;
                while (true){
                }
            }
        });
        thread.setName("xx");
        thread.start();

        while (!getLock[0]){//不同处理器可能主线程始终读取到的值为false
        }
    }
```

改进如下：
```
    private static void magic(Object obj)  {
        AtomicBoolean getLock = new AtomicBoolean(false);
        Thread thread = new Thread(() -> {
            synchronized (obj){
                getLock.set(true);
                while (true){
                }
            }
        });
        thread.setName("xx");
        thread.start();

        while (!getLock.get()){
        }
    }
```

#### wait&notify/notifyall 

  wait是已经获取锁的线程释放锁，然后一直阻塞等待其他线程调用相同锁的notify/notifyall方法；notify/notifyall是已经获取锁的线程释放锁，通知其他阻塞在相同锁的wait方法上的其他一个或多个线程中的一个线程继续执行。

  wait、notify、notifyall与synchronized配合使用

  可以得出如下方式：

  ```
    private static void magic(Object obj)  {
        Object obj2 = new Object();

        synchronized (obj2){
            Thread thread = new Thread(() -> {
                synchronized (obj){
                    // 锁定obj后，获取obj2的锁，获取成功即可nofity主线程继续执行
                    synchronized (obj2){
                        obj2.notify();
                    }
                    while (true){
                    }
                }
            });
            thread.setName("xx");
            thread.start();
            try {
                obj2.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
  ```

#### Condition&Lock
java的ReentrantLock结合Condition，跟notify/wait机制类似.

```
    private static void magic(Object obj)  {
        ReentrantLock reentrantLock = new ReentrantLock();
        Condition childThreadHasGetLock = reentrantLock.newCondition();

        reentrantLock.lock();

        Thread thread = new Thread(() -> {
            synchronized (obj){
                reentrantLock.lock();
                childThreadHasGetLock.signal();
                reentrantLock.unlock();

                while (true){
                }
            }
        });

        thread.setName("xx");
        thread.start();

        try {
            childThreadHasGetLock.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        reentrantLock.unlock();
    }
```

#### CountDownLatch
CountDownLatch，闭锁，基于AQS（AQS基于volatitle&CAS），阻塞的线程（一个或多个）一旦等闭锁的初始设置的计数值变为0就会恢复执行，最常用场景就是主线程等待多个外部调用都完成后（n个外部调用，闭锁的计数值为n），恢复执行。

```
    private static void magic(Object obj)  {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Thread thread = new Thread(() -> {
            synchronized (obj){
                countDownLatch.countDown();
                while (true){

                }
            }
        });
        thread.setName("xx");
        thread.start();
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

#### CyclicBarrier
CyclicBarrier，循环屏障，可以重复使用，基于Lock&Condition（Lock，Condition基于volatitle&CAS）,常用场景是一组线程在一个屏障点集合，所有线程到达后才会恢复线程的执行，可以设置在最后一个线程到达后所有线程恢复执行前的执行操作（一个屏障点只执行一次，可以更新一些状态，共享变量等）

```
    private static void magic(Object obj)  {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
        Thread thread = new Thread(() -> {
            synchronized (obj){
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException |BrokenBarrierException e) {
                    e.printStackTrace();
                }
                while (true){
                }
            }
        });
        thread.setName("xx");
        thread.start();

        try {
            cyclicBarrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
``` 

#### Phaser
阶段器，基于volatitle&CAS，多个阶段，多个线程分阶段共同开始去完成每一个阶段（每一个阶段完成线程等待未完成线程）的场景，在这大材小用

```
    private static void magic(Object obj)  {
        Phaser phaser = new Phaser(2);
        Thread thread = new Thread(() -> {
            synchronized (obj){
                phaser.arriveAndAwaitAdvance();
                while (true){
                }
            }
        });
        thread.setName("xx");
        thread.start();

        phaser.arriveAndAwaitAdvance();
    }
```

#### Semaphore
信号量，基于AQS，对有限的资源的并发访问控制，相比于加锁性能更高.

```
    private static void magic(Object obj) {
        Semaphore semaphore = new Semaphore(0);
        Thread thread = new Thread(() -> {
            synchronized (obj) {
                semaphore.release();// 子线程释放一个信号量，主线程才会继续执行
                while (true) {
                }
            }
        });
        thread.setName("xx");
        thread.start();

        try {
            semaphore.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

#### 同步队列
SynchronousQueue简单实现，其他类似Queue也行。

```
  private static void magic(Object obj) {
        SynchronousQueue<Boolean> synchronousQueue = new SynchronousQueue();
        Thread thread = new Thread(() -> {
            synchronized (obj) {
                synchronousQueue.offer(true);
                while (true) {
                }
            }
        });
        thread.setName("xx");
        thread.start();

        try {
            synchronousQueue.take();//获取不到一直阻塞
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

#### LockSupport
lock辅助工具类

```
     private static void magic(Object obj) {
        Thread mainThread = Thread.currentThread();
        Thread thread = new Thread(() -> {
            synchronized (obj) {
                LockSupport.unpark(mainThread);
                while (true) {
                }
            }
        });
        thread.setName("xx");
        thread.start();
        LockSupport.park();
    }
```

###总结
线程协作（单进程里的多个线程），通信的方式无非是共享变量即共享内存，锁（java提供的线程通讯机制，wait&notify，lock&condition，CountDownLatch等几个并发辅助类都是），管道（SynchronousQueue是队列，也可以理解为管道一种，PipedInputStream实现类似）

今天来探讨一下线程间协作的两种方式：Object.wait() Object.notify() 和 Condition， 分为4个部分

1.wait() notify() notifyAll()
2.Condition
3.生产者，消费者模型的实现

1.wait() notify() 和 notifyAll()

wait() notify() 和 notifyAll() 都是Object类中的方法
public final native void wait(long timeout) throws InterruptedException;

public final native void notify();
public final native void notifyAll();
看文字描述(请到Object类中查看，没有贴出)后，可知：
wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写。
调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）
调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；
调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；

还有一个问题是，为什么这3个方法不是Thread类中的方法，而是Object中的方法：
    这是因为，java中的锁是对象级别的，由于每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然要通过对象来进行操作了。如果用当前线程来操作，因为当前线程可能会等待多个线程的锁，就非常复杂了。

上面已经提到，如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。

调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；

notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。

同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。

nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。

这里要注意一点：notify()和notifyAll()方法只是唤醒等待该对象的monitor的线程，并不决定哪个线程能够获取到monitor。

举个简单的例子：假如有三个线程Thread1、Thread2和Thread3都在等待对象objectA的monitor，此时Thread4拥有对象objectA的monitor，当在Thread4中调用objectA.notify()方法之后，Thread1、Thread2和Thread3只有一个能被唤醒。注意，被唤醒不等于立刻就获取了objectA的monitor，也不代表能够立即执行，必须要等到分配CPU时间片。假若在Thread4中调用objectA.notifyAll()方法，则Thread1、Thread2和Thread3三个线程都会被唤醒，至于哪个线程接下来能够获取到objectA的monitor就具体依赖于操作系统的调度了。

上面尤其要注意一点，一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。

demo如下，执行结果永远都是Thread2的先执行完。
public class ThreadCommunication1 {

   public static Object obj = new Object();

   public static void main(String[] args){
       Thread thread1 = new Thread1();
       Thread thread2 = new Thread2();

       thread1.start();
       try {
           Thread.sleep(2000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       thread2.start();
   }

   static class Thread1 extends Thread {
       @Override
       public void run() {
           synchronized (obj) {
               try {
                   obj.wait();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println("线程"  + Thread.currentThread().getName() + "获得了锁");
           }
       }
   }

   static class Thread2 extends Thread {
       @Override
       public void run() {
           synchronized (obj) {
               obj.notify();
               System.out.println("线程" + Thread.currentThread().getName() + "调用了notify");
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println("线程" + Thread.currentThread().getName() + "释放了锁");
           }
       }
   }
}

2.Condition

Condition是在java1.5中才出现的，它用来替代传统的Object中的wait() notify()实现线程间的协作。相比使用Object的wait()
notify()，使用Condition的await(), signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，
其实，并发包下面的阻塞队列就是用Condition来实现线程间协作的。

Condition是个接口，基本的方法就是await()和signal()方法；
Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()
调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用

Conditon中的await()对应Object的wait()；
Condition中的signal()对应Object的notify()；
Condition中的signalAll()对应Object的notifyAll()。

关于Condition的剖析单独写下

3.生产者，消费者模型的实现

用wait() notify()方式实现生产者，消费者
public class ProcucerConsumer1 {

   private static final int LENGTH = 10;
   private static PriorityQueue<Integer> queue = new PriorityQueue<>(LENGTH);

   public static void main(String[] args){
       new Producer().start();
       new Consumer().start();
   }

   static class Producer extends Thread {
       @Override
       public void run() {
           produce();
       }

       private void produce() {
           while (true) {
               synchronized (queue) {
                   while (queue.size() == LENGTH) {
                       try {
                           System.out.println("队列已满,等到消费!");
                           queue.wait();
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                           queue.notify();
                       }
                   }
                   queue.offer(1);
                   queue.notify();
                   System.out.println("生产一个商品,剩余空间为" + (LENGTH - queue.size()));
               }
           }
       }
   }

   static class Consumer extends Thread {
       @Override
       public void run() {
           consume();
       }

       public void consume() {
           while (true) {
               synchronized (queue) {
                   while (queue.size() == 0) {
                       try {
                           System.out.println("队列为空,不能消费");
                           queue.wait();
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                           queue.notify();
                       }
                   }
                   queue.poll();
                   queue.notify();
                   System.out.println("消费一个商品,剩余商品个数:" + queue.size());
               }
           }
       }
   }
}

用condition实现生产者，消费者
public class ProducerConsumer2 {

   private static Lock lock = new ReentrantLock();
   private static Condition notFull = lock.newCondition();
   private static Condition notEmpty = lock.newCondition();
   private static final int LENGTH = 10;
   private static PriorityQueue<Integer> queue = new PriorityQueue<Integer>(LENGTH);

   public static void main(String[] args) {
       new Producer().start();
       new Consumer().start();
   }

   static class Producer extends Thread {
       @Override
       public void run() {
           produce();
       }

       private void produce() {
           while (true) {
               lock.lock();
               try {
                   while (queue.size() == LENGTH) {
                       try {
                           System.out.println("队列已满,等待消费!");
                           notFull.await();
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                       }
                   }
                   queue.offer(1);
                   notEmpty.signal();
                   System.out.println("生产一个商品,剩余空间为" + (LENGTH - queue.size()));
               } finally {
                   lock.unlock();
               }
           }
       }
   }

   static class Consumer extends Thread {
       @Override
       public void run() {
           consumer();
       }

       private void consumer() {
           while (true) {
               lock.lock();
               try {
                   while (queue.size() == 0) {
                       System.out.println("队列为空,不能消费");
                       try {
                           notEmpty.await();
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                       }
                   }
                   queue.poll();
                   notFull.signal();
                   System.out.println("消费一个商品,剩余商品个数:" + queue.size());
               } finally {
                   lock.unlock();
               }
           }
       }
   }
}
